
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
</head>

<body>
  <script>
    // JSON : JavaScript Object Notation
    // 데이터를 문자열의 형태로 주고 받도록 만들어진 내장 객체

    // const student = {
    //   name: 'it',
    //   age: 30,
    //   courses: ['linux', 'html/css', 'js']
    // }

    // console.log(student);

    // // 1. 프론트 -> 서버로 데이터를 전송할 때
    // // ? : 문자열로 전송하는 것이 메모리적으로도 효율적
    // // 2. 서버 -> 프론트로 데이터를 전송할 떄
    // // stringify() : js 객체를 문자열로 변경
    // let jsonStudent = JSON.stringify(student);
    // console.log(jsonStudent);

    // // 1. 프론트 / 서버가 받은 데이터를 자신의 객체로 바꾸어서 사용할 떄
    // // parse : 문자열을 js 객체로 변경
    // let newStudent = JSON.parse(jsonStudent);
    // console.log(newStudent);

    // // json을 사용할 때 key도 문자열로 변경해야 한다.
    // // *** 😀json을 사용할때에는 반드시 ""사용해야함!!!
    // let obj1 = { key1: 'v1' };
    // let obj2 = "{'key2': 'v2'}";
    // let obj3 = '{"key3": "v3"}';

    // console.log(obj1.key1);
    // console.log(JSON.parse(obj3).key3);

    // // XMLHttpsRequest
    // function ajaxTest() {
    //   var xhr = new XMLHttpRequest();

    //   // onreadystatechange
    //   // client와 server간에 통신을 할 때
    //   // 중간 단계에 대한 변화를 감지하여 자동으로 실행되는 로직

    //   // readystate 숫자로 표현
    //   // 1 : 요청 시작
    //   // 2 : 요청 중
    //   // 3 : 응답 중
    //   // 4 : 응답 완료

    //   // status 200 : 정상 응답
    //   xhr.onreadystatechange = function () {
    //     // alert(this.readyState)
    //     if (this.readyState == 4 && this.status == 200) {
    //       console.log((JSON.parse(this.responseText)[3]).phone)
    //     }
    //   }
    //   // 실제 요청(방식, 요청주소, 비동기요청(true))
    //   xhr.open("GET", "https://jsonplaceholder.typicode.com/users", true)
    //   xhr.send();
    // }

    // ajaxTest();


    // fetch
    // fetch("https://jsonplaceholder.typicode.com/users")
    //   .then((response) => { return response.json() })
    //   .then((users) => { console.log(users) })

    // fetch 실제 사용
    // .으로 연결하는 것을 메서드 체이닝 이라고 함
    fetch('https://jsonplaceholder.typicode.com/posts/1')
      .then(response => response.json())
      .then(post => post.userId)
      .then(userId => "https://jsonplaceholder.typicode.com/users/" + userId)
      .then(url => fetch(url))
      .then(response => response.json())
      .then(user => console.log(user))
      .catch((err) => {})

    // 메소드의 종류와 활용 방법
    // 1. GET : 클라이언트가 서버에 특정 데이터를 요청할 때 사용하는 메소드
    // fetch의 기본 요청방식은 GET, 따라서 따로 지정할 필요가 없음

    // 2. POST : 클라이언트가 서버에 특정 데이터를 생성할 떄 사용하는 메소드
    // fetch("https://jsonplaceholder.typicode.com/posts/1", {
    //   method: "DELETE",
    // })
    // .then((response) => response.json())
    // .then((data) => console.log(data))

    // 3. PUT : 클라이언트가 서버에 특정 데이터의 정보를 수정할 때 사용하는 메소드

    // 4. DELETE : 클라이언트가 서버에 특정 데이터를 삭제할 때 사용하는 메소드


    // axios : 비동기 통신을 위한 프로미스 기반의 라이브러리
    // 라이브러리 vs 프레임워크
    axios.get("https://jsonplaceholder.typicode.com/users")
      .then((response) => response.data)
      .then((data) => data[3])
      .then((patricia) => console.log(patricia))
      .catch((err) => console.log(err))

    // fetch : pst, put, delete --> axios : post, put, delete
    // axios.post("https://jsonplaceholder.typicode.com/posts", {
    //   userId: 1,
    //   title: "post testing",
    //   body: "post testing!"
    // }).then(response => console.log(response))


    const bret = {
      "id": 1,
      "name": "Leanne Graham",
      "username": "Bret",
      "email": "Sincere@april.biz",
      "address": {
        "street": "Kulas Light",
        "suite": "Apt. 556",
        "city": "Gwenborough",
        "zipcode": "92998-3874",
        "geo": {
          "lat": "-37.3159",
          "lng": "81.1496"
        }
      },
      "phone": "1-770-736-8031 x56442",
      "website": "hildegard.org",
      "company": {
        "name": "Romaguera-Crona",
        "catchPhrase": "Multi-layered client-server neural-net",
        "bs": "harness real-time e-markets"
      }
    }

    // 객체 비구조화 할당
    // const obj = {
    //   a: 1,
    //   b: 2,
    //   name: "it"
    // }
    // console.log(obj.b);
    // let {a, b, name, c=0} = obj;
    // console.log(b)
    // console.log(name)
    // console.log(c)


    // name = "it2"
    // console.log(obj.name)

    // lat, lng ??
    // const {lat, lng} = bret.address.geo;
    // console.log(lat)
    // console.log(lng)

    // 배열 비구조화 할당
    const arr = [1, 2];
    const [one, two] = arr;

    console.log(one);
    console.log(two);

    const objArr = {
      info: {
        private: {
          name: 'js',
          age: 24,
          hobbies: ['programming, algorithm'],
        }
      },
      purpose: 'destructure test'
    }

    const { name, age, hobbies } = objArr.info.private;
    console.log(name);

    const newObj = {
      name,
      age,
      hobbies,
    }

    console.log(newObj);

    // rest(...)
    const avengers = ['토르', '스파이더맨', '닥터스트레인지'];
    const totalAvengers = [...avengers, '미스제인'];

    console.log(avengers);
    console.log(totalAvengers);

    //객체
    const planet = {
      continent: 'Asia'
    };

    const country = {
      ...planet,
      countryName: 'ROK'
    }

    const city = {
      // continent: 'Asia',
      // countryName: 'ROK',
      ...country,
      region: 'Busan'
    }

    console.log(planet);
    console.log(country);
    console.log(city);
    // 함수

    // function sum(x, y) {
    //   return x + y + z;
    // }

    function sum(...rest) {
      // console.log(rest);
      return rest.reduce((accumulator, currentValue) => (accumulator + currentValue), 0);
    }
    sum(1, 2, 3);
    console.log(sum(1, 2, 3, 5, 24, 5, 1, 56, 657))


    console.log('--async - await--')
    async function asyncTest() {
      return 'test';
    }

    asyncTest()
        .then(data => data)

    // async의 리턴값은 항상 프로미스 객체이다!     
    // 프로미스 객체가 리턴된다는 의미는
    // 비동기 함수의 처리 결과가 완벽하게 수행 되어야
    // 우리가 작업하는 로직에서 원하는 대로  결과가 
    // 출력 될 수 있을것!
  

    // await : 프로미스 객체의 수행 상태가 끝날 때까지 대기를 하다가 
    // 완벽하게 수행되고 난 뒤의 결과를 반환하는 키워드  

    async function awaitTest() {
      // fetch('https://jsonplaceholder.typicode.com/posts/1');

      const result1 = await new Promise((resolve) => setTimeout(() => resolve('test1'),3000));
      const result2 = await new Promise((resolve) => setTimeout(() => resolve('test2'),1000));

      console.log(result1);
      console.log(result2);
    }

    awaitTest();

    async function a() {
      await fetch('https://jsonplaceholder.typicode.com/posts/1');
    }

  </script>
</body>

</html>
